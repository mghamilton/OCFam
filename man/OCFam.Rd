% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/OCFam.R
\name{OCFam}
\alias{OCFam}
\title{OCFam}
\usage{
OCFam(
  ped,
  sire_count_by_age,
  dam_count_by_age,
  kinship_constraint = NA,
  iterations = 10,
  min_prop_fams = 0,
  max_parents_per_fam = 10000,
  fast = TRUE
)
}
\arguments{
\item{ped}{is a data frame with the following columns (class in parentheses):
\itemize{
 \item{'INDIV' is the individual identifier (character).}
 \item{'SIRE' is the male parent identifier (character).}
 \item{'DAM' is the female parent identifier (character).}
 \item{'FAM' is a full-sibling family identifier (character).}
 \item{'SEX' is the sex of the individual. "male" (or 1 = male), "female" (or 2 = female), NA if unknown.  If one animal is of unknown sex, sex will be ignored (integer or character).}
 \item{'BORN' integer indicating age class.  May be the year of birth if one age class per year or an integer indicating the sequence of age classes (integer).}
 \item{'EBV' is the estimated breeding value (numeric).}
 \item{'N_AS_PARENT_PREV' is the number of families in the next age class previously contributed to (integer).}
 \item{'AVAIL_PARENT' is TRUE if the individual is candidate parent of next age class (logical).}
 }}

\item{sire_count_by_age}{is scalar (discrete generations) or a vector (overlapping generations) representing required sires by age class. For example (overlapping generations), sire_count_by_age = c(20, 80, 0, 0) - oldest parental age class to youngest age class.}

\item{dam_count_by_age}{is scalar (discrete generations) or a vector (overlapping generations) representing required dams by age class. For example (overlapping generations), dam_count_by_age = c(20, 80, 0, 0) - oldest parental age class to youngest age class.}

\item{kinship_constraint}{is the maximum value of the mean kinship among families in the next age class, while mean EBV is maximised (max.EBV).  If NA there is no constraint placed on kinship and the average kinship is minimised while EBV is not considered (min.fPED) (numeric between 0 and 1; default = NA)}

\item{iterations}{specifies the number of iterations. The greater the number of iterations specified, the closer the solution will be to the optimum but the longer it will take to run (positive integer; default = 10)}

\item{min_prop_fams}{is the proportion of families to be retained (i.e. to contribute at least one parent) from the oldest age class with parental candidates (numeric between 0 and 1; default = 0)}

\item{max_parents_per_fam}{is the maximum number of parents to contribute from each family (integer; default = 10000)}

\item{fast}{when TRUE, only candidate parents with the highest estimated breeding values (EBVs) within each family are retained as candidate parents, up to the limit defined by max_parents_per_fam (logical; default = TRUE)}
}
\value{
'fam_contbn' is a data frame containing details of contributions by family:
\itemize{
 \item{'FAM' is a full-sibling family identifier (character).}
 \item{'N_INDIV_TOTAL' is the total count of parental contributions to the next age class (integer)}
 \item{N_AS_PAST_PARENT is the count of past parental contributions to the next age class  (integer).}
 \item{N_INDIV is the count of parental contributions to the next age class from the current OCFam run.  Equals N_INDIV_TOTAL minus N_AS_PAST_PARENT (integer)}
}

'parent_contbn' is a data frame containing details of contributions by individual:
\itemize{
 \item{'INDIV' is the individual identifier (character).}
 \item{'SIRE' is the male parent identifier (character).}
 \item{'DAM' is the female parent identifier (character).}
 \item{'FAM' is a full-sibling family identifier (character).}
 \item{'BORN' integer indicating age class.  May be the year of birth if one age class per year or an integer indicating the sequence of age classes (integer).}
 \item{'EBV' is the estimated breeding value (numeric).}
 \item{'N_AS_PARENT_PREV' is the number of families in the next age class previously contributed to (integer).}
 \item{'AVAIL_PARENT' is TRUE if the individual is candidate parent of next age class (logical).}
 \item{'RANK' individual rank based on EBV}
 \item{'AVAIL_OR_PAST_PARENT' is TRUE if AVAIL_PARENT is TRUE or the individual has previously been used as a parent in the next age class.}
 \item{'FAM_SIRE' is a full-sibling family identifier of the SIRE (character).}
 \item{'FAM_DAM' is a full-sibling family identifier of the DAM (character).}
 \item{'BREED' is the species.}
 \item{'MATURE' is sexually mature}
 \item{'IS_CANDIDATE' was considered a candidate parent in OCFam}
 \item{'N_TOTAL_AS_PARENT' is the total count of parental contributions to the next age class}
 \item{'ADDED_IN_LAST_ITERATION' individual was addes in the last iteration of OCFam.  Would be the first individuals to be removed in necessary.}
}

'candidate_parents' is a data frame containing details of candidate parents:
\itemize{
 \item{'INDIV' is the individual identifier (character).}
 \item{'N_AS_PARENT_PREV' is the number of families contributed to in the next age class prior to running optimal contributions (integer).}
 \item{'LB' is the low bound of possilbe contribution to the next age class}
 \item{'UB' is the upper bound of possilbe contribution to the next age class}
 \item{EXCLUDE_MAX_PARENTS_PER_FAM' If TRUE individual is excluded on the basis that there are better parents available from the family to meet the max_parents_per_fam constraint.}
}

'fit_out' is a vector containing details of the constraints applied in the implementation of optiSel.
}
\description{
This function addresses the rounding issue associated with standard optimal contributions, particularly in highly fecund species in which relatively few families are generated (or parents are used).
}
\examples{
#Retrieve small example data
ped_small <- OCFam::ped_small
tail(ped_small)

#Run OCFam function
OCFam_out_small <- OCFam::OCFam(ped = ped_small,
                             sire_count_by_age = 60,
                             dam_count_by_age = 60,
                             kinship_constraint = NA, #This is a small example.  Cannot constrain kinship_constraint.
                             iterations = 10,
                             min_prop_fams = 0.9,
                             max_parents_per_fam = 4,
                             fast = TRUE
)

OCFam_out_small$fit_out$mean
head(OCFam_out_small$fam_contbn)
head(OCFam_out_small$parent_contbn)

#Retrieve larger example (sex unknown)
ped_big <- OCFam::ped_big
tail(ped_big)

#Run OCFam function
OCFam_out_big <- OCFam::OCFam(ped = ped_big,
                             sire_count_by_age = c(20, 100),
                             dam_count_by_age = c(10, 110),
                             kinship_constraint = 0.014,
                             iterations = 10,
                             min_prop_fams = 0,
                             max_parents_per_fam = 4,
                             fast = TRUE
)

OCFam_out_big$fit_out$mean
head(OCFam_out_big$fam_contbn)
head(OCFam_out_big$parent_contbn)
}
